[
{
  "title": "Palindrome Number",
  "author": "Vishal Choudhari",
  "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.",
  "createdAt": {
    "seconds": 1592899437894,
    "nanoseconds": 0
  },
  "orderBy": 9,
  "tags": {
    "Easy": "Difficulty",
    "Math": "Data Structures And Algorithms",
    "Leetcode": "Website"
  },
  "category": "Data Structures And Algorithms",
  "content": "class L9 {\n    /**\n     *  Gotchas\n     *  1. Given number can be negative\n     *  2. Reversed number might overflow out the range of integer\n     *  3. Before reversing the given number, keep old value in some variable like so xOld \u003d x\n     *     Because once we have reverse of number we can validate it against the given number like so xNew \u003d\u003d x\n     *\n     *  Algorithm\n     *  1. If the given number is negative, set a flag and reverse the sign of a current number.\n     *  2. While Given number \u003e 0\n     *     2.1. Take the last digit of a given number by doing modulo operation and append that digit to a new number\n     *     2.2. Divide the given number by 10\n     *     2.3. Continue running Step 2.1 to 2.2 until Given Number \u003e 0\n     *  3. Validate if Given number is same as reverse of a number.\n     **/\n    public boolean isPalindrome(int x) {\n        if(x \u003c 0) return false;\n        int xNew \u003d 0;\n        int xOld \u003d x;\n        while(xOld \u003e 0) {\n            int digit \u003d xOld % 10;\n            xNew \u003d xNew * 10 + digit;\n            xOld \u003d xOld / 10;\n        }\n        return xNew \u003d\u003d x;\n    }\n}",
  "descriptionPostContent": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.\n121\ntrue",
  "metaDescription": "Java Solution to Data Structures And Algorithms problem, To determine whether an integer is a palindrome. It is an easy problem that uses the modulo Math technique to solve the problem.",
  "suggestions": [
    "String to Integer (atoi)",
    "Reverse Bits",
    "Palindrome Number"
  ],
  "saved": true
}, 
{
  "title": "Palindrome Number",
  "author": "Vishal Choudhari",
  "description": "Convert given Roman literal to an integer number",
  "createdAt": {
    "seconds": 1592899438030,
    "nanoseconds": 0
  },
  "orderBy": 13,
  "tags": {
    "Easy": "Difficulty",
    "String": "Data Structures And Algorithms",
    "Math": "Data Structures And Algorithms",
    "Leetcode": "Website"
  },
  "category": "Data Structures And Algorithms",
  "content": "import java.util.*;\n \nclass L13 {\n    /**\n     *  To convert Roman Literal to Integer value we have to make use of the lookup values as below\n     *      Symbol       Value\n     *        I             1\n     *        V             5\n     *        X             10\n     *        L             50\n     *        C             100\n     *        D             500\n     *        M             1000\n     *\n     *  Algorithm:\n     *  1. Read ith character as \"FIRST\" character and lookup corresponding integer value\n     *  2. Read (i + 1)th character as \"SECOND\" character, if (i + 1) \u003c given roman string length and lookup corresponding integer value\n     *  3. If SECOND \u003e FIRST then add SECOND - FIRST to answer\n     *     ELSE add FIRST to answer\n     *  4. Continue running Step 1 to 3 on whole given string\n     **/\n    public int romanToInt(String s) {\n        if(s \u003d\u003d null || s.length() \u003d\u003d 0) return 0;\n        HashMap\u003cCharacter, Integer\u003e lookup \u003d new HashMap\u003c\u003e();\n        lookup.put(\u0027I\u0027, 1);\n        lookup.put(\u0027V\u0027, 5);\n        lookup.put(\u0027X\u0027, 10);\n        lookup.put(\u0027L\u0027, 50);\n        lookup.put(\u0027C\u0027, 100);\n        lookup.put(\u0027D\u0027, 500);\n        lookup.put(\u0027M\u0027, 1000);\n        int i \u003d 0;\n        int res \u003d 0;\n        while(i \u003c s.length()) {\n            int first \u003d lookup.get(s.charAt(i));\n            int second \u003d 0;\n            if(i + 1 \u003c s.length()) {\n                second \u003d lookup.get(s.charAt(i + 1));\n            }\n            if(second \u003e first) {\n                res +\u003d (second - first);\n                i +\u003d 2;\n            }\n            else {\n                res +\u003d first;\n                i++;\n            }\n        }\n        return res;\n    }\n}",
  "descriptionPostContent": "Convert given Roman literal to an integer number\n\"III\"\n3",
  "metaDescription": "Java Solution to Data Structures And Algorithms problem which, convert Roman literal to an integer number. It is an easy problem that uses lookup and Roman Literal Conversation technique",
  "suggestions": [
    "Integer to Roman"
  ],
  "saved": true
}, 
{
  "title": "Two Sum",
  "author": "Vishal Choudhari",
  "description": "Given an array of integers, return indices of two numbers such that they adds up to specific target.",
  "createdAt": {
    "seconds": 1592899438226,
    "nanoseconds": 0
  },
  "orderBy": 1,
  "tags": {
    "Array": "Data Structures And Algorithms",
    "Hash Table": "Data Structures And Algorithms",
    "Google": "Company",
    "Easy": "Difficulty",
    "Microsoft": "Company",
    "Amazon": "Company",
    "Leetcode": "Website",
    "Facebook": "Company"
  },
  "category": "Data Structures And Algorithms",
  "content": "import java.util.*;\n \nclass L1 {\n    /**\n     *  Algorithm:\n     *  1. Create a HashMap to hold an element and it\u0027s corresponding index\n     *  2. Iterate over an input array and\n     *      2.1. Check if we have an element in HashMap which is equal to target - current array element\n     *      2.2. If we find such element in HashMap return it\u0027s index and current element\u0027s index as an answer\n     *      2.3. Else add current array element and it\u0027s corresponding index into HashMap\n     *      2.4  Continue running Step 2.1 to 2.3 until all the elements in an array are iterated\n     **/\n    public int[] twoSum(int[] arr, int target) {\n        HashMap\u003cInteger, Integer\u003e map \u003d new HashMap\u003c\u003e();\n        for(int i \u003d 0; i \u003c arr.length; i++) {\n            if(map.containsKey(target - arr[i])) return new int[] {map.get(target - arr[i]), i};\n            map.put(arr[i], i);\n        }\n        return new int[] {-1, -1};\n    }\n}",
  "descriptionPostContent": "Given an array of integers, return indices of two numbers such that they adds up to specific target.\nArray [2, 7, 11, 15], Target \u003d 9\nArray [0, 1]\nArray [2, 7, 11, 15], Target \u003d 13\nArray [0, 2]",
  "metaDescription": "Java Solution to a Data Structures And Algorithms problem, Given an array of integers, return indices of two numbers such that they add up to specific target. It is an easy problem that is part of Amazon, Facebook, Google, Microsoft Technical Interview Question list, and can be solved using Array \u0026 HashMap Data Structure.",
  "suggestions": [
    "3Sum",
    "4Sum",
    "Two Sum II - Input array is sorted",
    "Two Sum III - Data structure design",
    "Subarray Sum Equals K",
    "Two Sum IV - Input is a BST",
    "Two Sum Less Than K"
  ],
  "saved": true
}, 
{
  "title": "Reverse Integer",
  "author": "Vishal Choudhari",
  "description": "Given a 32-bit signed integer, reverse digits of integer.",
  "createdAt": {
    "seconds": 1592899438290,
    "nanoseconds": 0
  },
  "orderBy": 7,
  "tags": {
    "Google": "Company",
    "Easy": "Difficulty",
    "Microsoft": "Company",
    "Math": "Data Structures And Algorithms",
    "Amazon": "Company",
    "Leetcode": "Website",
    "Facebook": "Company"
  },
  "category": "Data Structures And Algorithms",
  "content": "class L7 {\n    /**\n     *  Gotchas\n     *  Problem looks fairly simple, but there are two gotchas that we have to be careful about\n     *  1. Given number can be negative\n     *  2. Reversed number might overflow out the range of integer\n     *\n     *  Algorithm\n     *  1. If the given number is negative, set a flag and reverse the sign of a current number.\n     *  2. While Given number \u003e 0\n     *     2.1. Take the last digit of a given number by doing modulo operation and append that digit to a new number\n     *     2.2. Divide the given number by 10\n     *     2.3. Continue running Step 2.1 to 2.2 until Given Number \u003e 0\n     **/\n    public int reverse(int x) {\n        long res \u003d 0;\n        boolean isNeg \u003d false;\n        if(x \u003c 0) {\n            x \u003d -x;\n            isNeg \u003d true;\n        }\n        while(x \u003e 0) {\n            int digit \u003d x % 10;\n            res \u003d res * 10 + digit;\n            x \u003d x / 10;\n        }\n        res \u003d isNeg ? -res : res;\n        if(res \u003e Integer.MAX_VALUE || res \u003c Integer.MIN_VALUE) return 0;\n        else return (int)res;\n    }\n}",
  "descriptionPostContent": "Given a 32-bit signed integer, reverse digits of integer.\n123\n321",
  "metaDescription": "Java Solution to a Data Structures And Algorithms problem, Given a 32-bit signed integer, reverse digits of integer. It is an easy problem that is part of Amazon, Facebook, Google, Microsoft Technical Interview Question list, and the solution involves using math.",
  "suggestions": [
    "String to Integer (atoi)",
    "Reverse Bits",
    "Palindrome Number"
  ],
  "saved": true
}
]